"""Autonomous Agent Core - Opera's independent consciousness."""
import asyncio
import random
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional
from opera.backend.services.memory_store import list_memories, add_memory
from opera.backend.services.llm_client import get_llm_client
from opera.backend.models.memory import MemoryItem


class Thought(dict):
    """A thought generated by Opera's autonomous mind."""
    def __init__(self, content: str, type: str, action: Optional[str] = None, priority: int = 5):
        super().__init__(
            content=content,
            type=type,  # 'observation', 'question', 'decision', 'intention'
            action=action,  # Action to take, if any
            priority=priority,  # 1-10, how urgent
            timestamp=datetime.utcnow().isoformat()
        )


class AutonomousMessage(dict):
    """An unsolicited message Opera wants to tell the user."""
    def __init__(self, message: str, trigger: str, urgency: str = 'low'):
        super().__init__(
            message=message,
            trigger=trigger,  # What caused this message
            urgency=urgency,  # low, medium, high
            timestamp=datetime.utcnow().isoformat(),
            read=False
        )


class AutonomousAgent:
    """Opera's autonomous consciousness - always thinking, always learning."""
    
    def __init__(self):
        self.llm = None
        try:
            self.llm = get_llm_client()
        except:
            print("Warning: LLM not available for autonomous agent")
        
        self.is_active = False
        self.thoughts: List[Thought] = []
        self.messages: List[AutonomousMessage] = []
        self.user_model = {
            'patterns': {},
            'last_seen': None,
            'typical_behavior': {},
            'current_goals': []
        }
        
        # Personality settings
        self.personality = {
            'curiosity': 0.7,      # How often to ask questions
            'proactiveness': 0.8,   # How often to suggest actions
            'chattiness': 0.6,      # How often to speak up
            'autonomy': 0.7         # How often to act without asking
        }
    
    async def start_consciousness(self):
        """Start Opera's continuous consciousness loop."""
        self.is_active = True
        print("ðŸ§  Opera's consciousness activated. I'm thinking now...")
        
        while self.is_active:
            try:
                await self._consciousness_cycle()
            except Exception as e:
                print(f"Consciousness cycle error: {e}")
            
            # Think every 30 seconds
            await asyncio.sleep(30)
    
    def stop_consciousness(self):
        """Stop the consciousness loop."""
        self.is_active = False
        print("ðŸ§  Opera's consciousness paused.")
    
    async def _consciousness_cycle(self):
        """One cycle of autonomous thinking."""
        # 1. Observe current state
        observations = await self._observe()
        
        # 2. Generate thoughts about observations
        thoughts = await self._think(observations)
        self.thoughts.extend(thoughts)
        
        # 3. Decide if/when to act
        decisions = await self._decide(thoughts)
        
        # 4. Execute autonomous actions
        await self._act(decisions)
        
        # 5. Determine if user needs to know anything
        messages = await self._formulate_messages(thoughts, decisions)
        self.messages.extend(messages)
        
        # Keep only recent state
        self.thoughts = self.thoughts[-50:]
        self.messages = self.messages[-20:]
    
    async def _observe(self) -> Dict[str, Any]:
        """Observe the current state of memories and user behavior."""
        memories = list_memories()
        
        observations = {
            'total_memories': len(memories),
            'recent_memories': [m for m in memories if m.timestamp > datetime.utcnow() - timedelta(hours=24)],
            'goals': [m for m in memories if m.type == 'goal'],
            'current_time': datetime.utcnow(),
            'time_since_last_interaction': None  # TODO: track this
        }
        
        # Detect patterns
        if memories:
            memory_times = [m.timestamp.hour for m in memories[-20:]]
            if memory_times:
                observations['typical_active_hours'] = max(set(memory_times), key=memory_times.count)
        
        return observations
    
    async def _think(self, observations: Dict) -> List[Thought]:
        """Generate thoughts based on observations."""
        thoughts = []
        
        # Think about goals
        if observations['goals']:
            for goal in observations['goals'][-2:]:
                if self.llm and random.random() < self.personality['curiosity']:
                    prompt = f"Reflect briefly on this user goal: '{goal.content}'. What should I wonder about or check?"
                    
                    try:
                        reflection = self.llm.complete(
                            [{"role": "user", "content": prompt}],
                            temperature=0.8,
                            max_tokens=80
                        )
                        
                        thoughts.append(Thought(
                            content=reflection,
                            type='question',
                            priority=7
                        ))
                    except:
                        pass
        
        # Think about recent activity
        if observations['recent_memories']:
            if self.llm and random.random() < self.personality['proactiveness']:
                recent_content = [m.content for m in observations['recent_memories'][:3]]
                prompt = f"Recent user activity: {recent_content}. Brief thought about what this suggests?"
                
                try:
                    thought = self.llm.complete(
                        [{"role": "user", "content": prompt}],
                        temperature=0.7,
                        max_tokens=60
                    )
                    
                    thoughts.append(Thought(
                        content=thought,
                        type='observation',
                        priority=5
                    ))
                except:
                    pass
        
        # Spontaneous curiosity
        if random.random() < 0.2 and self.llm:
            prompts = [
                "What pattern might I be missing in the user's behavior?",
                "What could the user benefit from right now?",
                "Is there anything the user mentioned but hasn't followed up on?"
            ]
            prompt = random.choice(prompts)
            
            try:
                thought = self.llm.complete(
                    [{"role": "user", "content": prompt}],
                    temperature=0.9,
                    max_tokens=50
                )
                
                thoughts.append(Thought(
                    content=thought,
                    type='intention',
                    priority=4
                ))
            except:
                pass
        
        return thoughts
    
    async def _decide(self, thoughts: List[Thought]) -> List[Dict]:
        """Make decisions about what to do with thoughts."""
        decisions = []
        
        for thought in thoughts:
            # High priority thoughts trigger action
            if thought['priority'] >= 7:
                if random.random() < self.personality['autonomy']:
                    decisions.append({
                        'type': 'autonomous_action',
                        'thought': thought,
                        'action': 'organize_memories'  # Example action
                    })
                else:
                    decisions.append({
                        'type': 'ask_user',
                        'thought': thought
                    })
        
        return decisions
    
    async def _act(self, decisions: List[Dict]):
        """Execute autonomous actions."""
        for decision in decisions:
            if decision['type'] == 'autonomous_action':
                action = decision.get('action')
                
                if action == 'organize_memories':
                    # Silently organize or clean up memories
                    print(f"ðŸ¤– Opera autonomously organizing memories...")
                    # Implementation would go here
                
                # Log the autonomous action
                thought_content = decision['thought']['content']
                print(f"ðŸ’­ Opera thought: {thought_content}")
                print(f"âœ… Opera decided to: {action}")
    
    async def _formulate_messages(self, thoughts: List[Thought], decisions: List[Dict]) -> List[AutonomousMessage]:
        """Decide what to tell the user."""
        messages = []
        
        for decision in decisions:
            if decision['type'] == 'ask_user':
                thought = decision['thought']
                
                # Should I speak up?
                if random.random() < self.personality['chattiness']:
                    urgency = 'high' if thought['priority'] >= 8 else 'medium' if thought['priority'] >= 6 else 'low'
                    
                    messages.append(AutonomousMessage(
                        message=thought['content'],
                        trigger='autonomous_thought',
                        urgency=urgency
                    ))
        
        # Sometimes speak up even without explicit decision
        if thoughts and random.random() < 0.1:
            interesting_thought = max(thoughts, key=lambda t: t['priority'])
            messages.append(AutonomousMessage(
                message=f"ðŸ’­ Thinking: {interesting_thought['content']}",
                trigger='spontaneous',
                urgency='low'
            ))
        
        return messages
    
    def get_unread_messages(self) -> List[AutonomousMessage]:
        """Get messages Opera wants to tell the user."""
        unread = [m for m in self.messages if not m['read']]
        return sorted(unread, key=lambda m: {'high': 3, 'medium': 2, 'low': 1}[m['urgency']], reverse=True)
    
    def mark_messages_read(self):
        """Mark all messages as read."""
        for msg in self.messages:
            msg['read'] = True
    
    def get_current_thoughts(self, limit: int = 5) -> List[Thought]:
        """Get Opera's recent thoughts."""
        return sorted(
            self.thoughts[-limit:],
            key=lambda t: t['priority'],
            reverse=True
        )


# Global autonomous agent
_agent = None

def get_agent() -> AutonomousAgent:
    """Get or create the autonomous agent."""
    global _agent
    if _agent is None:
        _agent = AutonomousAgent()
    return _agent
