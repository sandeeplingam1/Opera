"""Background reasoning service for proactive intelligence."""
import asyncio
from datetime import datetime, timedelta
from typing import List, Dict, Any
from opera.backend.services.memory_store import list_memories
from opera.backend.services.llm_client import get_llm_client
from opera.backend.models.memory import MemoryItem


class Insight(dict):
    """A proactive insight generated by Opera."""
    def __init__(self, type: str, message: str, priority: str, memories: List[int] = None):
        super().__init__(
            type=type,
            message=message,
            priority=priority,  # 'low', 'medium', 'high'
            memories=memories or [],
            timestamp=datetime.utcnow().isoformat()
        )


class BackgroundReasoner:
    """Runs periodic background analysis to generate proactive insights."""
    
    def __init__(self):
        self.llm = None
        try:
            self.llm = get_llm_client()
        except:
            print("LLM not available for background reasoning")
        
        self.insights: List[Insight] = []
    
    async def run_periodic_analysis(self, interval_seconds: int = 300):
        """Run analysis every N seconds."""
        while True:
            try:
                await self.analyze()
            except Exception as e:
                print(f"Background analysis error: {e}")
            
            await asyncio.sleep(interval_seconds)
    
    async def analyze(self) -> List[Insight]:
        """Run all analysis tasks and generate insights."""
        new_insights = []
        
        # Get all memories
        memories = list_memories()
        
        # Run different analysis types
        new_insights.extend(await self._detect_patterns(memories))
        new_insights.extend(await self._track_goals(memories))
        new_insights.extend(await self._find_connections(memories))
        new_insights.extend(await self._suggest_actions(memories))
        
        # Store insights
        self.insights.extend(new_insights)
        
        # Keep only recent insights (last 100)
        self.insights = self.insights[-100:]
        
        return new_insights
    
    async def _detect_patterns(self, memories: List[MemoryItem]) -> List[Insight]:
        """Detect recurring patterns in memories."""
        insights = []
        
        # Group by content similarity (simple keyword matching)
        patterns = {}
        for memory in memories:
            words = set(memory.content.lower().split())
            for word in words:
                if len(word) > 4:  # Only meaningful words
                    patterns[word] = patterns.get(word, 0) + 1
        
        # Find frequent patterns
        frequent = [(word, count) for word, count in patterns.items() if count >= 3]
        
        if frequent and self.llm:
            # Use LLM to generate insight
            top_patterns = sorted(frequent, key=lambda x: x[1], reverse=True)[:5]
            prompt = f"Analyze these recurring topics in my memories: {top_patterns}. Give a brief insight about patterns you see."
            
            try:
                insight_text = self.llm.complete(
                    [{"role": "user", "content": prompt}],
                    temperature=0.7,
                    max_tokens=150
                )
                
                insights.append(Insight(
                    type="pattern",
                    message=insight_text,
                    priority="medium"
                ))
            except:
                pass
        
        return insights
    
    async def _track_goals(self, memories: List[MemoryItem]) -> List[Insight]:
        """Track progress on stated goals."""
        insights = []
        
        # Find goal memories
        goals = [m for m in memories if m.type == "goal"]
        
        if goals and self.llm:
            # Check goal progress
            for goal in goals[-3:]:  # Last 3 goals
                # See if there are recent memories related to this goal
                recent_memories = [
                    m for m in memories 
                    if m.timestamp > datetime.utcnow() - timedelta(days=7)
                ]
                
                if recent_memories:
                    prompt = f"Goal: {goal.content}\nRecent activity: {[m.content for m in recent_memories[:5]]}\nBrief progress update?"
                    
                    try:
                        update = self.llm.complete(
                            [{"role": "user", "content": prompt}],
                            temperature=0.7,
                            max_tokens=100
                        )
                        
                        insights.append(Insight(
                            type="goal_tracking",
                            message=f"Goal Update: {update}",
                            priority="high",
                            memories=[goal.id]
                        ))
                    except:
                        pass
        
        return insights
    
    async def _find_connections(self, memories: List[MemoryItem]) -> List[Insight]:
        """Find interesting connections between memories."""
        insights = []
        
        # Simple heuristic: find memories with shared keywords
        if len(memories) > 10 and self.llm:
            # Take recent memories
            recent = memories[-20:]
            
            prompt = f"Find an interesting connection between these memories:\n{[m.content for m in recent[:5]]}"
            
            try:
                connection = self.llm.complete(
                    [{"role": "user", "content": prompt}],
                    temperature=0.8,
                    max_tokens=120
                )
                
                insights.append(Insight(
                    type="connection",
                    message=connection,
                    priority="low"
                ))
            except:
                pass
        
        return insights
    
    async def _suggest_actions(self, memories: List[MemoryItem]) -> List[Insight]:
        """Suggest proactive actions based on memory analysis."""
        insights = []
        
        # Find preferences and suggest actions
        preferences = [m for m in memories if m.type == "preference"]
        
        if preferences and self.llm:
            pref = preferences[-1]
            prompt = f"Based on this preference: '{pref.content}', suggest one proactive action I could take."
            
            try:
                suggestion = self.llm.complete(
                    [{"role": "user", "content": prompt}],
                    temperature=0.7,
                    max_tokens=100
                )
                
                insights.append(Insight(
                    type="suggestion",
                    message=suggestion,
                    priority="medium",
                    memories=[pref.id]
                ))
            except:
                pass
        
        return insights
    
    def get_insights(self, limit: int = 10) -> List[Insight]:
        """Get recent insights."""
        return sorted(
            self.insights[-limit:],
            key=lambda x: x['timestamp'],
            reverse=True
        )


# Global background reasoner instance
_background_reasoner = None

def get_background_reasoner() -> BackgroundReasoner:
    """Get or create the global background reasoner."""
    global _background_reasoner
    if _background_reasoner is None:
        _background_reasoner = BackgroundReasoner()
    return _background_reasoner
